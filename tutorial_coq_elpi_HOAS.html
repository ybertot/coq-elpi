<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Tutorial on the HOAS for Coq terms</title>
<meta name="author" content="Enrico Tassi" />
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="tutorial-on-the-hoas-for-coq-terms">
<h1 class="title">Tutorial on the HOAS for Coq terms</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Enrico Tassi</td></tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<script>
var style = document.createElement('style');
style.textContent = `
  table.docinfo {
     border-top: none;
     border-bottom: none;
     margin: auto;
  }
  #alectryon-toggle-0 {
     display: none;
  }
  label[for="alectryon-toggle-0"] {
     display: none;
  }
  .alectryon-io {
     border-left-style: dotted;
     border-left-color: lightgrey;
     padding-left: 1em;
     margin-left: 1em;
  }
  pre.alectryon-block {
     padding-left: 1em;
  }
  label.alectryon-input.alectryon-failed {
     text-decoration: red wavy underline;
  }
  .alectryon-io label.alectryon-input::after , .alectryon-banner .alectryon-bubble::before {
    content: '';
    background: url("data:image/svg+xml,%3Csvg width='14' height='14' viewBox='0 0 3.704 3.704' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill-rule='evenodd' stroke='%23000' stroke-width='.264'%3E%3Cpath d='M.794.934h2.115M.794 1.463h1.455M.794 1.992h1.852'/%3E%3C/g%3E%3Cpath d='M.132.14v2.646h.794v.661l.926-.661h1.72V.14z' fill='none' stroke='%23000' stroke-width='.265'/%3E%3C/svg%3E") top right no-repeat;
    height: 14px;
    width: 14px;
    border-style: none;
    border-radius: 0px;
  }
  code.coq , code.elpi {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     padding: 0.2em 0.3em 0.2em 0.3em;
     border-radius: 0.5em
  }
  body {
    line-height: 2;
  }
  div.warning , div.important, div.note, div.tip {
     border-style: solid;
     border-color: lightgrey;
     border-width: 0.1em;
     border-radius: 0.5em
  }
  .ghref {
    cursor: help;
    text-decoration: underline dotted;
    font-family: 'Iosevka Slab Web', 'Iosevka Web', 'Iosevka Slab', 'Iosevka', 'Fira Code', monospace;
    font-feature-settings: "XV00" 1; /* Use Coq ligatures when Iosevka is available */
    line-height: initial;
  }

  .elpi {
    font-family: 'Iosevka Slab Web', 'Iosevka Web', 'Iosevka Slab', 'Iosevka', 'Fira Code', monospace;
    font-feature-settings: "XV00" 1; /* Use Coq ligatures when Iosevka is available */
   }

  .highlight .-ElpiFunction , .highlight .n-ElpiFunction { color: #795E26 }
  .highlight .-ElpiVariable , .highlight .n-ElpiVariable { color: #0000ff }
  .highlight .k-ElpiKeyword { color: #AF00DB }
  .highlight .k-ElpiMode { color: #811f3f }
  .highlight .m-ElpiInteger { color: #098658 }
  .highlight .si { color: rgb(94, 93, 93) }

  .elpi .n-ElpiFunction { color: #795E26 }
  .elpi .n-ElpiVariable { color: #0000ff }
  .elpi .k-ElpiKeyword { color: #AF00DB }
  .elpi .k-ElpiMode { color: #811f3f }
  .elpi .m-ElpiInteger { color: #098658 }
  .elpi .s2 { color: #a31515 }
  .elpi .c { color: #008000 }
  .elpi .kt { color: #2b91af }
  .elpi .si { color: rgb(94, 93, 93) }

  .admonition-title:after { content: ":" }
  .admonition-title { display: inline; margin-right: 0.5em }
  .admonition-title + p { display: inline }

  .important .admonition-title { color: rgb(197, 70, 91) }
  .important { background-color: rgb(272, 237, 243) }

  .note .admonition-title { color: rgb(42, 134, 57) }
  .note { background-color: rgb(222, 247, 222); }


`;
document.getElementsByTagName('head')[0].appendChild(style);

</script><!-- Elpi is an extension language that comes as a library
to be embedded into host applications such as Coq.

Elpi is a variant of ŒªProlog enriched with constraints.
ŒªProlog is a programming language designed to make it easy
to manipulate abstract syntax trees containing binders.
Elpi extends ŒªProlog with programming constructs that are
designed to make it easy to manipulate abstract syntax trees
containing metavariables (also called unification variables, or
evars in the Coq jargon).

This software, "coq-elpi", is a Coq plugin embedding Elpi and
exposing to the extension language Coq spefic data types (e.g. terms)
and API (e.g. to declare a new inductive type).

In order to get proper syntax highlighting using VSCode please install the
"gares.coq-elpi-lang" extension. In CoqIDE please chose "coq-elpi" in
Edit -> Preferences -> Colors. -->
<p>This tutorial focuses on the integration of Elpi within Coq, in particular
it describes how Coq terms are exposed to Elpi programs and how Coq APIs can
be called.</p>
<p>This tutorial assumes the reader is familiar with Elpi and HOAS; if it is not
the case, please take a look at the
<a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_elpi_lang.html">Elpi tutorial</a>
first.</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#hoas-for-gallina" id="toc-entry-1">HOAS for Gallina</a><ul>
<li><a class="reference internal" href="#constructor-global" id="toc-entry-2">Constructor <code class="e elpi">global</code></a></li>
<li><a class="reference internal" href="#constructors-app-and-fun" id="toc-entry-3">Constructors <code class="e elpi">app</code> and <code class="e elpi">fun</code></a></li>
<li><a class="reference internal" href="#constructors-fix-and-match" id="toc-entry-4">Constructors <code class="e elpi">fix</code> and <code class="e elpi">match</code></a></li>
<li><a class="reference internal" href="#constructor-sort" id="toc-entry-5">Constructor <code class="e elpi">sort</code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#quotations-and-antiquotations" id="toc-entry-6">Quotations and Antiquotations</a></li>
<li><a class="reference internal" href="#the-context" id="toc-entry-7">The context</a></li>
<li><a class="reference internal" href="#holes-implicit-arguments" id="toc-entry-8">Holes (implicit arguments)</a><ul>
<li><a class="reference internal" href="#outside-the-pattern-fragment" id="toc-entry-9">Outside the pattern fragment</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="hoas-for-gallina">
<h1><a class="toc-backref" href="#toc-entry-1">HOAS for Gallina</a></h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">
</span></pre><p>The full syntax of Coq terms can be found in
<a class="reference external" href="https://github.com/LPCIC/coq-elpi/blob/master/coq-builtin.elpi">coq-builtin.elpi</a>
together with a detailed documentation of the encoding of contexts and the
APIs one can use to interact with Coq. This tutorial, and the two more
that focus on commands and tactics, are a gentle introduction to all that.</p>
<p>We defer to later quotations and antiquotations: syntactic features that
let one write terms in Coq's native syntax. Here we focus on the abstract
syntax tree of Coq terms.</p>
<div class="section" id="constructor-global">
<h2><a class="toc-backref" href="#toc-entry-2">Constructor <code class="e elpi">global</code></a></h2>
<p>Let's start with the <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L553">gref</a> data type (for global rerence).</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">type</span> <span class="n-ElpiFunction">const</span> <span class="kt">constant</span> <span class="kt">-&gt;</span> <span class="kt">gref</span>.
<span class="k-ElpiKeyword">type</span> <span class="n-ElpiFunction">indt</span> <span class="kt">inductive</span> <span class="kt">-&gt;</span> <span class="kt">gref</span>.
<span class="k-ElpiKeyword">type</span> <span class="n-ElpiFunction">indc</span> <span class="kt">constructor</span> <span class="kt">-&gt;</span> <span class="kt">gref</span>.
</pre>
<p><a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L541">constant</a>, <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L545">inductive</a> and <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L549">constructor</a> are Coq specific
data types that are opaque to Elpi. Still the <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L553">gref</a> data type lets you
see what these names point to (a constant, and inductive type or a
constructor).</p>
<p>The <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L582">coq.locate</a> API resolves a string to a <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L553">gref</a>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk0"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  coq.locate <span class="s2">&quot;nat&quot;</span> <span class=" -ElpiVariable">GRnat</span><span class="k k-ElpiKeyword">,</span>
  coq.locate <span class="s2">&quot;S&quot;</span> <span class=" -ElpiVariable">GRs</span><span class="k k-ElpiKeyword">,</span>
  coq.locate <span class="s2">&quot;plus&quot;</span> <span class=" -ElpiVariable">GRplus</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">GRnat = indt ¬´nat¬ª</blockquote><blockquote class="alectryon-message">GRplus = const ¬´Nat.add¬ª</blockquote><blockquote class="alectryon-message">GRs = indc ¬´S¬ª</blockquote></div></div></small></span></pre><p>The <code class="e elpi">coq.env<span class="o">.</span><span class="k-ElpiKeyword">*</span></code> family of APIs lets one access the
environment of well typed Coq terms that have a global name.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">x</span> := <span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk1"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  coq.locate <span class="s2">&quot;x&quot;</span> <span class=" -ElpiVariable">GR</span><span class="k k-ElpiKeyword">,</span>

  <span class="c">% all global references have a type</span>
  coq.env.typeof <span class=" -ElpiVariable">GR</span> <span class=" -ElpiVariable">Ty</span><span class="k k-ElpiKeyword">,</span>

  <span class="c">% destruct GR to obtain its constant part C</span>
  <span class=" -ElpiVariable">GR</span> <span class="k k-ElpiKeyword">=</span> const <span class=" -ElpiVariable">C</span><span class="k k-ElpiKeyword">,</span>

  <span class="c">% constants may have a body, do have a type</span>
  coq.env.const <span class=" -ElpiVariable">C</span> (some <span class=" -ElpiVariable">Bo</span>) <span class=" -ElpiVariable">TyC</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">Bo = app [<span class="kn">global</span> (indc ¬´S¬ª), app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]]</blockquote><blockquote class="alectryon-message">C = ¬´x¬ª</blockquote><blockquote class="alectryon-message">GR = const ¬´x¬ª</blockquote><blockquote class="alectryon-message">Ty = <span class="kn">global</span> (indt ¬´nat¬ª)</blockquote><blockquote class="alectryon-message">TyC = <span class="kn">global</span> (indt ¬´nat¬ª)</blockquote></div></div></small></span></pre><p>An expression like <code class="e elpi">indt&nbsp;<span class="err">¬´</span>nat<span class="err">¬ª</span></code> is not a Coq term (or better a type) yet.</p>
<p>The <a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L82">global</a> term constructor turns a <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L553">gref</a> into an
actual <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L77">term</a>.</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">type</span> <span class="n-ElpiFunction">global</span> <span class="kt">gref</span> <span class="kt">-&gt;</span> <span class="kt">term</span>.
</pre>
</div>
<div class="section" id="constructors-app-and-fun">
<h2><a class="toc-backref" href="#toc-entry-3">Constructors <code class="e elpi">app</code> and <code class="e elpi">fun</code></a></h2>
<p>The <a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L91">app</a> term constructor takes a list of terms and builds
the (n-ary) application. The first term is the head, while the others
are the arguments.</p>
<p>For example <code class="e elpi">app&nbsp;<span class="k-ElpiKeyword">[</span>global&nbsp;(indc&nbsp;<span class="err">¬´</span><span class="n-ElpiVariable">S</span><span class="err">¬ª</span><span class="o">)</span><span class="k-ElpiKeyword">,</span>&nbsp;global&nbsp;(indc&nbsp;<span class="err">¬´</span><span class="n-ElpiVariable">O</span><span class="err">¬ª</span><span class="o">)</span><span class="k-ElpiKeyword">]</span></code> is
the representation of <code class="highlight coq"><span class="mi">1</span></code>.</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">type</span> <span class="n-ElpiFunction">app</span>   <span class="kt">list</span> <span class="kt">term</span> <span class="kt">-&gt;</span> <span class="kt">term</span>.
</pre>
<p>Let's move to binders!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">f</span> := <span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk2"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  coq.locate <span class="s2">&quot;f&quot;</span> (const <span class=" -ElpiVariable">C</span>)<span class="k k-ElpiKeyword">,</span>
  coq.env.const <span class=" -ElpiVariable">C</span> (some <span class=" -ElpiVariable">Bo</span>) <span class=" -ElpiVariable">_</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">Bo = <span class="kr">fun</span> `x` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \ c0</blockquote><blockquote class="alectryon-message">C = ¬´f¬ª</blockquote></div></div></small></span></pre><p>The <a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L86">fun</a> constructor carries a pretty printing hint <tt class="docutils literal">`x`</tt>,
the type of the bound variable <code class="highlight coq"><span class="n">nat</span></code> and a function describing the body:</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">type</span> <span class="n-ElpiFunction">fun</span>  <span class="kt">name</span> <span class="kt">-&gt;</span> <span class="kt">term</span> <span class="kt">-&gt;</span> <span class="kt">(term</span> <span class="kt">-&gt;</span> <span class="kt">term)</span> <span class="kt">-&gt;</span> <span class="kt">term</span>.
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L1567">name</a> is just for pretty printing: in spite of carrying
a value in the Coq world, it has no content in Elpi (like the unit type)</p>
<p>Elpi terms of type <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L1567">name</a> are just identifiers
written between <tt class="docutils literal">`</tt> (backticks).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk3"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class="k k-ElpiKeyword">fun</span> `foo` <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">B</span> <span class="k k-ElpiKeyword">=</span> <span class="k k-ElpiKeyword">fun</span> `bar` <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">B</span>    <span class="c">% names don&#39;t matter</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">B = X0</blockquote><blockquote class="alectryon-message">T = X1</blockquote></div></div></small></span></pre><p class="last">API such as <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L1570">coq.name-suffix</a> lets one craft a family of
names starting from one, eg <tt class="docutils literal"><span class="pre">coq.name-suffix</span> `H` 1 N</tt> sets <code class="e elpi"><span class="n-ElpiVariable">N</span></code>
to <tt class="docutils literal">`H1`</tt>.</p>
</div>
</div>
<div class="section" id="constructors-fix-and-match">
<h2><a class="toc-backref" href="#toc-entry-4">Constructors <code class="e elpi">fix</code> and <code class="e elpi">match</code></a></h2>
<p>The other binders <a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L87">prod</a> (Coq's <code class="highlight coq"><span class="kr">forall</span></code>, AKA <code class="highlight coq"><span class="n">Œ†</span></code>) and <a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L88">let</a> are similar,
so let's rather focus on <a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L93">fix</a> here.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk4"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  coq.locate <span class="s2">&quot;plus&quot;</span> (const <span class=" -ElpiVariable">C</span>)<span class="k k-ElpiKeyword">,</span>
  coq.env.const <span class=" -ElpiVariable">C</span> (some <span class=" -ElpiVariable">Bo</span>) <span class=" -ElpiVariable">_</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message"> Bo = <span class="kr">fix</span> `add` <span class="mi">0</span> 
(prod `n` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
  prod `m` (<span class="kn">global</span> (indt ¬´nat¬ª)) c1 \ <span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
<span class="kr">fun</span> `n` (<span class="kn">global</span> (indt ¬´nat¬ª)) c1 \
 <span class="kr">fun</span> `m` (<span class="kn">global</span> (indt ¬´nat¬ª)) c2 \
  <span class="kr">match</span> c1 (<span class="kr">fun</span> `n` (<span class="kn">global</span> (indt ¬´nat¬ª)) c3 \ <span class="kn">global</span> (indt ¬´nat¬ª)) 
   [c2, 
    <span class="kr">fun</span> `p` (<span class="kn">global</span> (indt ¬´nat¬ª)) c3 \
     app [<span class="kn">global</span> (indc ¬´S¬ª), app [c0, c3, c2]]]</blockquote><blockquote class="alectryon-message">C = ¬´Nat.add¬ª</blockquote></div></div></small></span></pre><p>The <a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L93">fix</a> constructor carries a pretty printing hint,
the number of the recursive argument (starting at <code class="e elpi"><span class="m-ElpiInteger">0</span></code>), the type 
of the recursive function and finally the body where the recursive
call is represented via a bound variable</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">type</span> <span class="n-ElpiFunction">fix</span>   <span class="kt">name</span> <span class="kt">-&gt;</span> <span class="kt">int</span> <span class="kt">-&gt;</span> <span class="kt">term</span> <span class="kt">-&gt;</span> <span class="kt">(term</span> <span class="kt">-&gt;</span> <span class="kt">term)</span> <span class="kt">-&gt;</span> <span class="kt">term</span>.
</pre>
<p>A <a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L92">match</a> constructor carries the term being inspected,
the return clause
and a list of branches. Each branch is a Coq function expecting in input
the arguments of the corresponding constructor. The order follows the
order of the constructors in the inductive type declaration.</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">type</span> <span class="n-ElpiFunction">match</span> <span class="kt">term</span> <span class="kt">-&gt;</span> <span class="kt">term</span> <span class="kt">-&gt;</span> <span class="kt">list</span> <span class="kt">term</span> <span class="kt">-&gt;</span> <span class="kt">term</span>.
</pre>
<p>The return clause is represented as a Coq function expecting in input
the indexes of the inductive type, the inspected term and generating the
type of the branches.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">m</span> (<span class="nv">h</span> : <span class="mi">0</span> = <span class="mi">1</span> ) <span class="nv">P</span> : P <span class="mi">0</span> -&gt; P <span class="mi">1</span> :=
  <span class="kr">match</span> h <span class="kr">as</span> e <span class="kr">in</span> eq _ x <span class="kr">return</span> P <span class="mi">0</span> -&gt; P x
  <span class="kr">with</span> eq_refl =&gt; <span class="kr">fun</span> (<span class="nv">p</span> : P <span class="mi">0</span>) =&gt; p <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk5"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

coq.locate <span class="s2">&quot;m&quot;</span> (const <span class=" -ElpiVariable">C</span>)<span class="k k-ElpiKeyword">,</span>
coq.env.const <span class=" -ElpiVariable">C</span> (some (<span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">h\</span> <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">p\</span> <span class="k k-ElpiKeyword">match</span> <span class=" -ElpiVariable">_</span> (<span class=" -ElpiVariable">RT</span> h p) <span class=" -ElpiVariable">_</span>)) <span class=" -ElpiVariable">_</span><span class="k k-ElpiKeyword">,</span>
coq.say <span class="s2">&quot;The return type of m is:&quot;</span> <span class=" -ElpiVariable">RT</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The <span class="kr">return</span> <span class="kp">type of</span> m <span class="kr">is</span>: c0 \ c1 \
<span class="kr">fun</span> `x` (<span class="kn">global</span> (indt ¬´nat¬ª)) c2 \
 <span class="kr">fun</span> `e` 
  (app [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), <span class="kn">global</span> (indc ¬´O¬ª), c2]) 
  c3 \ prod `_` (app [c1, <span class="kn">global</span> (indc ¬´O¬ª)]) c4 \ app [c1, c2]</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">C = ¬´m¬ª</blockquote><blockquote class="alectryon-message">  RT = c0 \ c1 \
<span class="kr">fun</span> `x` (<span class="kn">global</span> (indt ¬´nat¬ª)) c2 \
 <span class="kr">fun</span> `e` 
  (app [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), <span class="kn">global</span> (indc ¬´O¬ª), c2]) 
  c3 \ prod `_` (app [c1, <span class="kn">global</span> (indc ¬´O¬ª)]) c4 \ app [c1, c2]</blockquote></div></div></small></span></pre></div>
<div class="section" id="constructor-sort">
<h2><a class="toc-backref" href="#toc-entry-5">Constructor <code class="e elpi">sort</code></a></h2>
<p>The last term constructor worth discussing is <a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L79">sort</a>.</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">type</span> <span class="n-ElpiFunction">sort</span>  <span class="kt">universe</span> <span class="kt">-&gt;</span> <span class="kt">term</span>.
<span class="k-ElpiKeyword">type</span> <span class="n-ElpiFunction">prop</span> <span class="kt">universe</span>.
<span class="k-ElpiKeyword">type</span> <span class="n-ElpiFunction">typ</span> <span class="kt">univ</span> <span class="kt">-&gt;</span> <span class="kt">universe</span>.
</pre>
<p>The opaque type <a class="type ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L924">univ</a> is a universe level variable. Elpi holds a store of
constraints among these variables and provides APIs named <code class="e elpi">coq.univ<span class="o">.</span><span class="k-ElpiKeyword">*</span></code> to
impose constraints.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk6"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  coq.sort.sup <span class=" -ElpiVariable">U</span> <span class=" -ElpiVariable">U1</span><span class="k k-ElpiKeyword">,</span>
  coq.say <span class=" -ElpiVariable">U</span> <span class="s2">&quot;&lt;&quot;</span> <span class=" -ElpiVariable">U1</span><span class="k k-ElpiKeyword">,</span>
  <span class="c">% This constraint can&#39;t be allowed in the store!</span>
  not(coq.sort.leq <span class=" -ElpiVariable">U1</span> <span class=" -ElpiVariable">U</span>)

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">typ ¬´tutorial_coq_elpi_HOAS.<span class="mi">6</span>¬ª &lt; typ ¬´tutorial_coq_elpi_HOAS.<span class="mi">7</span>¬ª</blockquote><blockquote class="alectryon-message">Cannot enforce tutorial_coq_elpi_HOAS.<span class="mi">7</span> &lt;=
tutorial_coq_elpi_HOAS.<span class="mi">6</span> because
tutorial_coq_elpi_HOAS.<span class="mi">6</span> &lt; tutorial_coq_elpi_HOAS.<span class="mi">7</span></blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">U = typ ¬´tutorial_coq_elpi_HOAS.<span class="mi">6</span>¬ª</blockquote><blockquote class="alectryon-message">U1 = typ ¬´tutorial_coq_elpi_HOAS.<span class="mi">7</span>¬ª</blockquote><blockquote class="alectryon-message"><span class="kn">Universe</span> <span class="nf">constraints</span>:
UNIVERSES:
 {tutorial_coq_elpi_HOAS.<span class="mi">7</span> tutorial_coq_elpi_HOAS.<span class="mi">6</span>} |=
   tutorial_coq_elpi_HOAS.<span class="mi">6</span> &lt; tutorial_coq_elpi_HOAS.<span class="mi">7</span>
ALGEBRAIC UNIVERSES:
 {}
UNDEFINED UNIVERSES:

WEAK CONSTRAINTS:

</blockquote></div></div></small></span></pre><div class="admonition note">
<p class="first admonition-title">Note</p>
<p>the user is not expected to declare universe constraints by hand</p>
<p class="last">The type checking primitives update the store of constraints
automatically and put Coq universe variables in place of Elpi's unification
variables (<code class="e elpi"><span class="n-ElpiVariable">U</span></code> and <code class="e elpi"><span class="n-ElpiVariable">V</span></code> below).</p>
</div>
<p>Let's play a bit more with universe constraints using the
<a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L1353">coq.typecheck</a> API:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk7"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">ID</span> <span class="k k-ElpiKeyword">=</span> (<span class="k k-ElpiKeyword">fun</span> `x` (<span class="k k-ElpiKeyword">sort</span> (typ <span class=" -ElpiVariable">U</span>)) <span class=" -ElpiVariable">x\</span> x)<span class="k k-ElpiKeyword">,</span>
  <span class=" -ElpiVariable">A</span> <span class="k k-ElpiKeyword">=</span> (<span class="k k-ElpiKeyword">sort</span> (typ <span class=" -ElpiVariable">U</span>))<span class="k k-ElpiKeyword">,</span> <span class="c">% the same U as before</span>
  <span class=" -ElpiVariable">B</span> <span class="k k-ElpiKeyword">=</span> (<span class="k k-ElpiKeyword">sort</span> (typ <span class=" -ElpiVariable">V</span>))<span class="k k-ElpiKeyword">,</span>
  coq.say <span class="s2">&quot;(id b) is:&quot;</span> (<span class="k k-ElpiKeyword">app</span> <span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">ID</span><span class="k k-ElpiKeyword">,</span> <span class=" -ElpiVariable">B</span><span class="k k-ElpiKeyword">]</span>)<span class="k k-ElpiKeyword">,</span>

  <span class="c">% error, since U : U is not valid</span>
  coq.typecheck (<span class="k k-ElpiKeyword">app</span> <span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">ID</span><span class="k k-ElpiKeyword">,</span> <span class=" -ElpiVariable">A</span><span class="k k-ElpiKeyword">]</span>) <span class=" -ElpiVariable">T</span> (error <span class=" -ElpiVariable">ErrMsg</span>)<span class="k k-ElpiKeyword">,</span>
  coq.say <span class="s2">&quot;(id a) is illtyped:&quot;</span> <span class=" -ElpiVariable">ErrMsg</span><span class="k k-ElpiKeyword">,</span>

  <span class="c">% ok, since V : U is possible</span>
  coq.typecheck (<span class="k k-ElpiKeyword">app</span> <span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">ID</span><span class="k k-ElpiKeyword">,</span> <span class=" -ElpiVariable">B</span><span class="k k-ElpiKeyword">]</span>) <span class=" -ElpiVariable">T</span> ok<span class="k k-ElpiKeyword">,</span>

  <span class="c">% remark: U and V are now Coq&#39;s univ with constraints</span>
  coq.say <span class="s2">&quot;after typing (id b) is:&quot;</span> (<span class="k k-ElpiKeyword">app</span> <span class="k k-ElpiKeyword">[</span><span class=" -ElpiVariable">ID</span><span class="k k-ElpiKeyword">,</span> <span class=" -ElpiVariable">B</span><span class="k k-ElpiKeyword">]</span>) <span class="s2">&quot;:&quot;</span> <span class=" -ElpiVariable">T</span><span class="k k-ElpiKeyword">,</span>
  coq.univ.print

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">(id b) <span class="kr">is</span>: app [<span class="kr">fun</span> `x` (sort (typ X0)) c0 \ c0, sort (typ X1)]</blockquote><blockquote class="alectryon-message">(id a) <span class="kr">is</span> illtyped: 
Illegal application: 
The term <span class="s2">&quot;fun x : Type =&gt; x&quot;</span> of type <span class="s2">&quot;Type -&gt; Type&quot;</span>
cannot be applied to the term
 <span class="s2">&quot;Type&quot;</span> : <span class="s2">&quot;Type&quot;</span>
This term has type <span class="s2">&quot;Type@{tutorial_coq_elpi_HOAS.8+1}&quot;</span>
which should be coercible to <span class="s2">&quot;Type@{tutorial_coq_elpi_HOAS.8}&quot;</span>.</blockquote><blockquote class="alectryon-message"><span class="nb">after</span> typing (id b) <span class="kr">is</span>: 
app
 [<span class="kr">fun</span> `x` (sort (typ ¬´tutorial_coq_elpi_HOAS.<span class="mi">8</span>¬ª)) c0 \ c0, 
  sort (typ ¬´tutorial_coq_elpi_HOAS.<span class="mi">9</span>¬ª)] : 
sort (typ ¬´tutorial_coq_elpi_HOAS.<span class="mi">8</span>¬ª)</blockquote><blockquote class="alectryon-message"><span class="kn">Universe</span> <span class="nf">constraints</span>: UNIVERSES:
                       {tutorial_coq_elpi_HOAS.<span class="mi">9</span>
                        tutorial_coq_elpi_HOAS.<span class="mi">8</span>} |=
                         tutorial_coq_elpi_HOAS.<span class="mi">9</span> &lt; tutorial_coq_elpi_HOAS.<span class="mi">8</span>
                      ALGEBRAIC UNIVERSES:
                       {tutorial_coq_elpi_HOAS.<span class="mi">9</span>
                        tutorial_coq_elpi_HOAS.<span class="mi">8</span>}
                      UNDEFINED UNIVERSES:
                       tutorial_coq_elpi_HOAS.<span class="mi">9</span>
                       tutorial_coq_elpi_HOAS.<span class="mi">8</span>
                      WEAK CONSTRAINTS:

</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">A = sort (typ ¬´tutorial_coq_elpi_HOAS.<span class="mi">8</span>¬ª)</blockquote><blockquote class="alectryon-message">B = sort (typ ¬´tutorial_coq_elpi_HOAS.<span class="mi">9</span>¬ª)</blockquote><blockquote class="alectryon-message">  ErrMsg = Illegal application: 
The term <span class="s2">&quot;fun x : Type =&gt; x&quot;</span> of type <span class="s2">&quot;Type -&gt; Type&quot;</span>
cannot be applied to the term
 <span class="s2">&quot;Type&quot;</span> : <span class="s2">&quot;Type&quot;</span>
This term has type <span class="s2">&quot;Type@{tutorial_coq_elpi_HOAS.8+1}&quot;</span>
which should be coercible to <span class="s2">&quot;Type@{tutorial_coq_elpi_HOAS.8}&quot;</span>.</blockquote><blockquote class="alectryon-message">ID = <span class="kr">fun</span> `x` (sort (typ ¬´tutorial_coq_elpi_HOAS.<span class="mi">8</span>¬ª)) c0 \ c0</blockquote><blockquote class="alectryon-message">T = sort (typ ¬´tutorial_coq_elpi_HOAS.<span class="mi">8</span>¬ª)</blockquote><blockquote class="alectryon-message">U = ¬´tutorial_coq_elpi_HOAS.<span class="mi">8</span>¬ª</blockquote><blockquote class="alectryon-message">V = ¬´tutorial_coq_elpi_HOAS.<span class="mi">9</span>¬ª</blockquote><blockquote class="alectryon-message"><span class="kn">Universe</span> <span class="nf">constraints</span>:
UNIVERSES:
 {tutorial_coq_elpi_HOAS.<span class="mi">9</span> tutorial_coq_elpi_HOAS.<span class="mi">8</span>} |=
   tutorial_coq_elpi_HOAS.<span class="mi">9</span> &lt; tutorial_coq_elpi_HOAS.<span class="mi">8</span>
ALGEBRAIC UNIVERSES:
 {tutorial_coq_elpi_HOAS.<span class="mi">9</span> tutorial_coq_elpi_HOAS.<span class="mi">8</span>}
UNDEFINED UNIVERSES:
 tutorial_coq_elpi_HOAS.<span class="mi">9</span>
 tutorial_coq_elpi_HOAS.<span class="mi">8</span>
WEAK CONSTRAINTS:

</blockquote></div></div></small></span></pre><p>The <a class="stdtype ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/elpi-builtin.elpi#L252">diagnostic</a> data type is used by <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L1353">coq.typecheck</a> to
tell if the term is well typed. The constructor <code class="e elpi">ok</code> signals success, while
<code class="e elpi">error</code> carries an error message. In case of success universe constraints
are added to the store.</p>
</div>
</div>
<div class="section" id="quotations-and-antiquotations">
<h1><a class="toc-backref" href="#toc-entry-6">Quotations and Antiquotations</a></h1>
<p>Writing Gallina terms as we did so far is surely possible but very verbose
and unhandy. Elpi provides a system of quotations and antiquotations to
let one take advantage of the Coq parser to write terms.</p>
<p>The antiquotation, from Coq to Elpi, is written <code class="highlight coq"><span class="si">lp:{{</span> <span class="o">...</span> <span class="si">}}</span></code> and we have
been using it since the beginning of the tutorial. The quotation from
Elpi to Coq is written <code class="e elpi"><span class="err">{</span>{:coq <span class="o">...</span> <span class="err">}</span>}</code> or also just <code class="e elpi"><span class="err">{</span>{ <span class="o">...</span> <span class="err">}</span>}</code> since
the <code class="highlight coq"><span class="o">:</span><span class="n">coq</span></code> is the default quotation (Coq has no default quotation, hence you always need
to write <code class="highlight coq"><span class="n">lp</span><span class="o">:</span></code> there).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk8"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class="c">% the &quot;:coq&quot; flag is optional</span>
  coq.say <span class="si">{{:coq</span> <span class="mi">1</span> + <span class="mi">2</span> <span class="si">}}</span> <span class="s2">&quot;=&quot;</span> <span class="si">{{</span> <span class="mi">1</span> + <span class="mi">2</span> <span class="si">}}</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">app
 [<span class="kn">global</span> (const ¬´Nat.add¬ª), 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], 
  app [<span class="kn">global</span> (indc ¬´S¬ª), app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]]] 
= 
app
 [<span class="kn">global</span> (const ¬´Nat.add¬ª), 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], 
  app [<span class="kn">global</span> (indc ¬´S¬ª), app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]]]</blockquote></div></div></small></span></pre><p>Of course quotations can nest.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk9"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  coq.locate <span class="s2">&quot;S&quot;</span> <span class=" -ElpiVariable">S</span><span class="k k-ElpiKeyword">,</span>
  coq.say <span class="si">{{</span> <span class="mi">1</span> + <span class="si">lp:{{</span> <span class="k k-ElpiKeyword">app[global</span> <span class=" -ElpiVariable">S</span><span class="k k-ElpiKeyword">,</span> <span class="si">{{</span> <span class="mi">0</span> <span class="si">}}</span> <span class="k k-ElpiKeyword">]</span>  <span class="si">}}</span>   <span class="si">}}</span>
<span class="c">% elpi....  coq..     elpi...........  coq  elpi  coq</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">app
 [<span class="kn">global</span> (const ¬´Nat.add¬ª), 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]]</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">S = indc ¬´S¬ª</blockquote></div></div></small></span></pre><p>One rule governs bound variables:</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">if a variable is bound in a language, Coq or Elpi,
then the variable is only visible in that language (not in the other one).</p>
</div>
<p>The following example is horrible but proves this point. In real code
you are encouraged to pick appropriate names for your variables, avoiding
gratuitous (visual) clashes.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chka"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  coq.say (<span class="k k-ElpiKeyword">fun</span> `x` <span class="si">{{</span>nat<span class="si">}}</span> <span class=" -ElpiVariable">x\</span> <span class="si">{{</span> <span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x + <span class="si">lp:{{</span> x <span class="si">}}</span> <span class="si">}}</span>)
<span class="c">%                          e         c          c         e</span>
<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kr">fun</span> `x` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
 <span class="kr">fun</span> `x` (<span class="kn">global</span> (indt ¬´nat¬ª)) c1 \
  app [<span class="kn">global</span> (const ¬´Nat.add¬ª), c1, c0]</blockquote></div></div></small></span></pre><p>A commodity quotation without parentheses let's one quote identifiers
omitting the curly braces.
That is <code class="highlight coq"><span class="si">lp:{{</span> ident <span class="si">}}</span></code> can be written just <code class="highlight coq"><span class="si">lp:</span><span class="n-ElpiVariable">ident</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chkb"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  coq.say (<span class="k k-ElpiKeyword">fun</span> `x` <span class="si">{{</span>nat<span class="si">}}</span> <span class=" -ElpiVariable">x\</span> <span class="si">{{</span> <span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x + <span class="si">lp:</span><span class=" -ElpiVariable">x</span> <span class="si">}}</span>)
<span class="c">%                          e         c          c      e</span>
<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kr">fun</span> `x` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
 <span class="kr">fun</span> `x` (<span class="kn">global</span> (indt ¬´nat¬ª)) c1 \
  app [<span class="kn">global</span> (const ¬´Nat.add¬ª), c1, c0]</blockquote></div></div></small></span></pre><p>It is quite frequent to put Coq variables in the scope of an Elpi
unification variable, and this can be done by simply writing
<code class="highlight coq"><span class="si">lp:(</span><span class="n-ElpiVariable">X</span> a b<span class="si">)</span></code> which is a shorhand for <code class="highlight coq"><span class="si">lp:{{</span> <span class="n-ElpiVariable">X</span> <span class="si">{{</span> <span class="n">a</span> <span class="si">}}</span> <span class="si">{{</span> <span class="n">b</span> <span class="si">}}</span> <span class="si">}}</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">writing <code class="highlight coq"><span class="si">lp:</span><span class="n-ElpiVariable">X</span> <span class="n">a</span> <span class="n">b</span></code> (without parentheses) would result in a
Coq application, not an Elpi one</p>
</div>
<p>Let's play a bit with these shorthands:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chkc"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">X</span> <span class="k k-ElpiKeyword">=</span> (<span class=" -ElpiVariable">x\y\</span> <span class="si">{{</span> <span class="si">lp:</span><span class=" -ElpiVariable">y</span> + <span class="si">lp:</span><span class=" -ElpiVariable">x</span> <span class="si">}}</span>)<span class="k k-ElpiKeyword">,</span> <span class="c">% x and y live in Elpi</span>

  coq.say <span class="si">{{</span> <span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : nat =&gt; <span class="si">lp:(</span><span class=" -ElpiVariable">X</span> a b<span class="si">)</span> <span class="si">}}</span> <span class="c">% a and b live in Coq</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kr">fun</span> `a` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
 <span class="kr">fun</span> `b` (<span class="kn">global</span> (indt ¬´nat¬ª)) c1 \
  app [<span class="kn">global</span> (const ¬´Nat.add¬ª), c1, c0]</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">  X = c0 \ c1 \
app [<span class="kn">global</span> (const ¬´Nat.add¬ª), c1, c0]</blockquote></div></div></small></span></pre><p>Another commodity quotation lets one access the coqlib
feature introduced in Coq 8.10.</p>
<p>Coqlib gives you an indirection between your code and the actual name
of constants.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Register</span> Coq.Init.Datatypes.nat <span class="kr">as</span> my.N.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Register</span> Coq.Init.Logic.eq <span class="kr">as</span> my.eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chkd"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  coq.say <span class="si">{{</span> <span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : lib:my.N =&gt; lib:@my.eq lib:my.N a b <span class="si">}}</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kr">fun</span> `a` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
 <span class="kr">fun</span> `b` (<span class="kn">global</span> (indt ¬´nat¬ª)) c1 \
  app [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), c0, c1]</blockquote></div></div></small></span></pre><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The (optional) <code class="highlight coq"><span class="o">&#64;</span></code> in <code class="highlight coq"><span class="n">lib</span><span class="o">:&#64;</span><span class="n">some</span><span class="o">.</span><span class="n">name</span></code> disables implicit arguments.</p>
</div>
<p>The <code class="highlight coq"><span class="o">{{:</span><span class="n">gref</span> <span class="o">..</span> <span class="o">}}</span></code> quotation lets one build the gref data type, instead of the
term one. It supports <code class="highlight coq"><span class="n">lib</span><span class="o">:</span></code> as well.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chke"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  coq.say <span class="si">{{:gref</span>  nat  <span class="si">}}</span><span class="k k-ElpiKeyword">,</span>
  coq.say <span class="si">{{:gref</span>  lib:my.N  <span class="si">}}</span>.

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">indt ¬´nat¬ª</blockquote><blockquote class="alectryon-message">indt ¬´nat¬ª</blockquote></div></div></small></span></pre><p>The last thing to keep in mind when using quotations is that implicit
arguments are inserted (according to the <code class="highlight coq"><span class="kn">Arguments</span></code> setting in Coq)
but not synthesized automatically.</p>
<p>It is the job of the type checker or elaborator to synthesize them.
We shall see more on this in the section on <a class="reference internal" href="#holes">holes</a>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chkf"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> (<span class="k k-ElpiKeyword">fun</span> `ax` <span class="si">{{</span>nat<span class="si">}}</span> <span class=" -ElpiVariable">a\</span> <span class="si">{{</span> <span class="kr">fun</span> <span class="nv">b</span> : nat =&gt; <span class="si">lp:</span><span class=" -ElpiVariable">a</span> = b <span class="si">}}</span>)<span class="k k-ElpiKeyword">,</span>
  coq.say <span class="s2">&quot;before:&quot;</span> <span class=" -ElpiVariable">T</span><span class="k k-ElpiKeyword">,</span>
  coq.typecheck <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">_</span> ok<span class="k k-ElpiKeyword">,</span>
  coq.say <span class="s2">&quot;after:&quot;</span> <span class=" -ElpiVariable">T</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="nb">before</span>: 
<span class="kr">fun</span> `ax` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
 <span class="kr">fun</span> `b` (<span class="kn">global</span> (indt ¬´nat¬ª)) c1 \
  app [<span class="kn">global</span> (indt ¬´eq¬ª), X0 c1, c0, c1]</blockquote><blockquote class="alectryon-message"><span class="nb">after</span>: 
<span class="kr">fun</span> `ax` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
 <span class="kr">fun</span> `b` (<span class="kn">global</span> (indt ¬´nat¬ª)) c1 \
  app [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), c0, c1]</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message"> T = <span class="kr">fun</span> `ax` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
<span class="kr">fun</span> `b` (<span class="kn">global</span> (indt ¬´nat¬ª)) c1 \
 app [<span class="kn">global</span> (indt ¬´eq¬ª), <span class="kn">global</span> (indt ¬´nat¬ª), c0, c1]</blockquote><blockquote class="alectryon-message">  _uvk_1_ = c0 \
<span class="kn">global</span> (indt ¬´nat¬ª)</blockquote><blockquote class="alectryon-message"><span class="kn">Universe</span> <span class="nf">constraints</span>:
UNIVERSES:
 {tutorial_coq_elpi_HOAS.<span class="mi">11</span> tutorial_coq_elpi_HOAS.<span class="mi">10</span>} |=
   tutorial_coq_elpi_HOAS.<span class="mi">11</span> &lt; tutorial_coq_elpi_HOAS.<span class="mi">10</span>
   <span class="kt">Set</span> &lt;= tutorial_coq_elpi_HOAS.<span class="mi">11</span>
   tutorial_coq_elpi_HOAS.<span class="mi">11</span> &lt;= eq.u0
ALGEBRAIC UNIVERSES:
 {}
UNDEFINED UNIVERSES:

WEAK CONSTRAINTS:

</blockquote></div></div></small></span></pre></div>
<div class="section" id="the-context">
<h1><a class="toc-backref" href="#toc-entry-7">The context</a></h1>
<p>The context of Elpi (the hypothetical program made of rules loaded
via <code class="e elpi"><span class="k-ElpiKeyword">=&gt;</span></code>) is taken into account by the Coq APIs. In particular every time
a bound variable is crossed, the programmer <em>must</em> load in the context a
rule attaching to that variable a type. There are a few facilities to
do that, but let's first see what happens if one forgets it.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-hoas-v-chk10"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="si">{{</span> <span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x + <span class="mi">1</span> <span class="si">}}</span><span class="k k-ElpiKeyword">,</span>
  coq.typecheck <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">_</span> ok<span class="k k-ElpiKeyword">,</span>
  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">Bo</span><span class="k k-ElpiKeyword">,</span>
  <span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">x</span>\
    coq.typecheck (<span class=" -ElpiVariable">Bo</span> x) <span class=" -ElpiVariable">_</span> <span class=" -ElpiVariable">_</span>

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Bound</span> variable c0 not found <span class="kr">in</span> the Coq <span class="kp">context</span>:
Mapping <span class="kn">from</span> DBL:


Named:

Rel:

Did you forget to load some hypotheses <span class="kr">with</span> =&gt; ?</blockquote></div></div></small></span></pre><p>This fatal error says that <code class="e elpi">x</code> in <code class="e elpi">(<span class="n-ElpiVariable">Bo</span> x<span class="o">)</span></code> is unknown to Coq. 
It is
a variable postulated in Elpi, but it's type, <code class="highlight coq"><span class="n">nat</span></code>, was lost. There
is nothing wrong per se in using <code class="e elpi"><span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ </code> as we did if we don't call Coq
APIs under it. But if we do, we have to record the type of <code class="e elpi">x</code> somewhere.</p>
<p>In some sense Elpi's way of traversing a binder is similar to a Zipper.
The context of Elpi must record the part of the Zipper context that is
relevant for binders.</p>
<p>The two predicates <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L163">decl</a> and <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L164">def</a> are used
for that purpose:</p>
<pre class="code elpi literal-block">
<span class="k-ElpiKeyword">pred</span> <span class="n-ElpiFunction">decl</span> <span class="k-ElpiMode">i:</span><span class="kt">term</span>, <span class="k-ElpiMode">o:</span><span class="kt">name</span>, <span class="k-ElpiMode">o:</span><span class="kt">term</span>.         <span class="c">% Var Name Ty
</span><span class="k-ElpiKeyword">pred</span> <span class="n-ElpiFunction">def</span>  <span class="k-ElpiMode">i:</span><span class="kt">term</span>, <span class="k-ElpiMode">o:</span><span class="kt">name</span>, <span class="k-ElpiMode">o:</span><span class="kt">term</span>, <span class="k-ElpiMode">o:</span><span class="kt">term</span>. <span class="c">% Var Name Ty Bo</span>
</pre>
<p>where <code class="e elpi">def</code> is used to cross a <code class="e elpi">let</code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk11"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="si">{{</span> <span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x + <span class="mi">1</span> <span class="si">}}</span><span class="k k-ElpiKeyword">,</span>
  coq.typecheck <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">_</span> ok<span class="k k-ElpiKeyword">,</span>
  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">N</span> <span class=" -ElpiVariable">Ty</span> <span class=" -ElpiVariable">Bo</span><span class="k k-ElpiKeyword">,</span>
  <span class="k k-ElpiKeyword">pi</span> <span class=" -ElpiVariable">x</span>\
    decl x <span class=" -ElpiVariable">N</span> <span class=" -ElpiVariable">Ty</span> <span class="k k-ElpiKeyword">=&gt;</span>
      coq.typecheck (<span class=" -ElpiVariable">Bo</span> x) <span class=" -ElpiVariable">_</span> ok

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">  Bo = c0 \
app
 [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]]</blockquote><blockquote class="alectryon-message">N = `x`</blockquote><blockquote class="alectryon-message"> T = <span class="kr">fun</span> `x` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
app
 [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]]</blockquote><blockquote class="alectryon-message">Ty = <span class="kn">global</span> (indt ¬´nat¬ª)</blockquote></div></div></small></span></pre><p>In order to ease this task, Coq-Elpi provides a few commodity macros such as
<code class="highlight coq"><span class="o">&#64;</span><span class="n">pi</span><span class="o">-</span><span class="n">decl</span></code>:</p>
<pre class="code elpi literal-block">
macro <span class="k-ElpiKeyword">&#64;</span>pi-decl <span class="n-ElpiVariable">N</span> <span class="n-ElpiVariable">T</span> <span class="n-ElpiVariable">F</span> <span class="k-ElpiKeyword">:-</span> <span class="k-ElpiKeyword">pi</span> <span class="n-ElpiVariable">x</span>\ decl x <span class="n-ElpiVariable">N</span> <span class="n-ElpiVariable">T</span> <span class="k-ElpiKeyword">=&gt;</span> <span class="n-ElpiVariable">F</span> x<span class="o">.</span>
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>the precedence of lambda abstraction <code class="e elpi"><span class="n-ElpiVariable">x\</span> </code> lets you write the
following code without parentheses for <code class="e elpi"><span class="n-ElpiVariable">F</span></code>.</p>
<div class="last"><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk12"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="si">{{</span> <span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x + <span class="mi">1</span> <span class="si">}}</span><span class="k k-ElpiKeyword">,</span>
  coq.typecheck <span class=" -ElpiVariable">T</span> <span class=" -ElpiVariable">_</span> ok<span class="k k-ElpiKeyword">,</span>
  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span>  <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">N</span> <span class=" -ElpiVariable">Ty</span> <span class=" -ElpiVariable">Bo</span><span class="k k-ElpiKeyword">,</span>
  <span class="k k-ElpiKeyword">@</span>pi-decl <span class=" -ElpiVariable">N</span> <span class=" -ElpiVariable">Ty</span> <span class=" -ElpiVariable">x\</span>
      coq.typecheck (<span class=" -ElpiVariable">Bo</span> x) <span class=" -ElpiVariable">_</span> ok

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">  Bo = c0 \
app
 [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]]</blockquote><blockquote class="alectryon-message">N = `x`</blockquote><blockquote class="alectryon-message"> T = <span class="kr">fun</span> `x` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
app
 [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]]</blockquote><blockquote class="alectryon-message">Ty = <span class="kn">global</span> (indt ¬´nat¬ª)</blockquote></div></div></small></span></pre></div></div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><code class="e elpi"><span class="k-ElpiKeyword">&#64;</span>pi-decl <span class="n-ElpiVariable">N</span> <span class="n-ElpiVariable">Ty</span> <span class="n-ElpiVariable">x\</span> </code> takes arguments in the same order of <a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L86">fun</a> and
<a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L87">prod</a>, while
<code class="e elpi"><span class="k-ElpiKeyword">&#64;</span>pi-def <span class="n-ElpiVariable">N</span> <span class="n-ElpiVariable">Ty</span> <span class="n-ElpiVariable">Bo</span> <span class="n-ElpiVariable">x\</span> </code> takes arguments in the same order of <a class="constructor ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L88">let</a>.</p>
</div>
</div>
<div class="section" id="holes-implicit-arguments">
<span id="holes"></span><h1><a class="toc-backref" href="#toc-entry-8">Holes (implicit arguments)</a></h1>
<p>An &quot;Evar&quot; (Coq slang for existentially quantified meta variable) is
represented as a Elpi unification variable and a typing constraint.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk13"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

    <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="si">{{</span> _ <span class="si">}}</span><span class="k k-ElpiKeyword">,</span>
    coq.say <span class="s2">&quot;raw T =&quot;</span> <span class=" -ElpiVariable">T</span><span class="k k-ElpiKeyword">,</span>
    coq.sigma.print<span class="k k-ElpiKeyword">,</span>
    coq.say <span class="s2">&quot;--------------------------------&quot;</span><span class="k k-ElpiKeyword">,</span>
    coq.typecheck <span class=" -ElpiVariable">T</span> <span class="si">{{</span> nat <span class="si">}}</span> ok<span class="k k-ElpiKeyword">,</span>
    coq.sigma.print

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">raw T = X0</blockquote><blockquote class="alectryon-message"></blockquote><blockquote class="alectryon-message">SHELF:
FUTURE GOALS STACK:

</blockquote><blockquote class="alectryon-message">Coq-<span class="kn">Elpi</span> mapping:
RAW:
ELAB:
</blockquote><blockquote class="alectryon-message">--------------------------------</blockquote><blockquote class="alectryon-message"><span class="nb">evar</span> (X1) (<span class="kn">global</span> (indt ¬´nat¬ª)) (X1)  /* suspended on X1 */</blockquote><blockquote class="alectryon-message">EVARS:
 <span class="nl">?X12</span>==[ |- nat] (internal placeholder) {<span class="nl">?elpi_evar</span>}
 <span class="nl">?X11</span>==[ |- nat =&gt; <span class="nl">?elpi_evar</span>] (internal placeholder)
 <span class="nl">?X10</span>==[ |- <span class="kt">Type</span> =&gt; nat] (internal placeholder)

SHELF:
FUTURE GOALS STACK:
 <span class="nl">?X12</span>
</blockquote><blockquote class="alectryon-message">Coq-<span class="kn">Elpi</span> mapping:
RAW:
<span class="nl">?X12</span> &lt;-&gt; X1
ELAB:
<span class="nl">?X12</span> &lt;-&gt; X1
</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">T = X1</blockquote><blockquote class="alectryon-message">_uvk_4_ = X1</blockquote><blockquote class="alectryon-message">Syntactic constraints:
 <span class="nb">evar</span> (X1) (<span class="kn">global</span> (indt ¬´nat¬ª)) (X1)  /* suspended on X1 */</blockquote><blockquote class="alectryon-message"><span class="kn">Universe</span> <span class="nf">constraints</span>:
UNIVERSES:
 {tutorial_coq_elpi_HOAS.<span class="mi">12</span>} |=
   <span class="kt">Set</span> &lt;= tutorial_coq_elpi_HOAS.<span class="mi">12</span>
ALGEBRAIC UNIVERSES:
 {}
UNDEFINED UNIVERSES:

WEAK CONSTRAINTS:

</blockquote></div></div></small></span></pre><p>Before the call to <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L1353">coq.typecheck</a>, <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L1349">coq.sigma.print</a>
prints nothing interesting, while after the call it also prints the following
syntactic constraint:</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->evar (<span class=" -ElpiVariable">X1</span>) (global (indt ¬´nat¬ª)) (<span class=" -ElpiVariable">X1</span>)  <span class="c">/* suspended on X1 */</span></pre><p>which indicates that the hole <code class="e elpi"><span class="n-ElpiVariable">X1</span></code> is linked to a Coq evar
and is expected to have type <code class="highlight coq"><span class="n">nat</span></code>.</p>
<p>Now the bijective mapping from Coq evars to Elpi's unification variables
is not empty anymore:</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->Coq-Elpi mapping:
RAW:
?X12 &lt;-&gt; X1
ELAB:
?X12 &lt;-&gt; X1
</pre><p>Note that Coq's evar identifiers are of the form <code class="highlight coq"><span class="nl">?X</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code>, while the Elpi ones
have no leading <code class="highlight coq"><span class="o">?</span></code>. The Coq Evar map says that <code class="highlight coq"><span class="nl">?X12</span></code> has type <code class="highlight coq"><span class="n">nat</span></code>:</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->EVARS:
 ?X12==[ |- nat] (internal placeholder) {?elpi_evar}
 ?X11==[ |- nat =&gt; ?elpi_evar] (internal placeholder)
 ?X10==[ |- Type =&gt; nat] (internal placeholder)

SHELF:
FUTURE GOALS STACK:
 ?X12
</pre><p>The intuition is that Coq's Evar map (AKA sigma or evd), which assigns
typing judgement to evars, is represented with Elpi constraints which carry
the same piece of info.</p>
<p>Naked Elpi unification variables, when passed to Coq's API, are
automatically linked to a Coq evar. We postpone the explanation of the
difference &quot;raw&quot; and &quot;elab&quot; unification variables to the chapter about
tactics, here the second copy of <code class="e elpi"><span class="n-ElpiVariable">X1</span></code> in the evar constraint plays
no role.</p>
<p>Now, what about the typing context?</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk14"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="si">{{</span> <span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x + _ <span class="si">}}</span><span class="k k-ElpiKeyword">,</span>
  coq.say <span class="s2">&quot;raw T =&quot;</span> <span class=" -ElpiVariable">T</span><span class="k k-ElpiKeyword">,</span>
  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">N</span> <span class=" -ElpiVariable">Ty</span> <span class=" -ElpiVariable">Bo</span><span class="k k-ElpiKeyword">,</span>
  <span class="k k-ElpiKeyword">@</span>pi-decl <span class=" -ElpiVariable">N</span> <span class=" -ElpiVariable">Ty</span> <span class=" -ElpiVariable">x\</span>
      coq.typecheck (<span class=" -ElpiVariable">Bo</span> x) <span class="si">{{</span> nat <span class="si">}}</span> ok<span class="k k-ElpiKeyword">,</span>
      coq.sigma.print.

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">raw T = 
<span class="kr">fun</span> `x` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
 app [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, X0 c0]</blockquote><blockquote class="alectryon-message">{c0 c1} : decl c1 `x` (<span class="kn">global</span> (indt ¬´nat¬ª))
  ?- <span class="nb">evar</span> (X1 c1) (<span class="kn">global</span> (indt ¬´nat¬ª)) (X1 c1)  /* suspended on X1 */</blockquote><blockquote class="alectryon-message">EVARS:
 <span class="nl">?X15</span>==[x |- nat] (internal placeholder) {<span class="nl">?elpi_evar</span>}
 <span class="nl">?X14</span>==[x |- nat =&gt; <span class="nl">?elpi_evar</span>] (internal placeholder)
 <span class="nl">?X13</span>==[x |- <span class="kt">Type</span> =&gt; nat] (internal placeholder)

SHELF:
FUTURE GOALS STACK:
 <span class="nl">?X15</span>
</blockquote><blockquote class="alectryon-message">Coq-<span class="kn">Elpi</span> mapping:
RAW:
<span class="nl">?X15</span> &lt;-&gt; X1
ELAB:
<span class="nl">?X15</span> &lt;-&gt; X1
</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">  Bo = c0 \
app [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, X1 c0]</blockquote><blockquote class="alectryon-message">N = `x`</blockquote><blockquote class="alectryon-message"> T = <span class="kr">fun</span> `x` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \
app [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, X1 c0]</blockquote><blockquote class="alectryon-message">Ty = <span class="kn">global</span> (indt ¬´nat¬ª)</blockquote><blockquote class="alectryon-message">  _uvk_9_ = c0 \
X1 c0</blockquote><blockquote class="alectryon-message">Syntactic constraints:
 {c0 c1} : decl c1 `x` (<span class="kn">global</span> (indt ¬´nat¬ª))
   ?- <span class="nb">evar</span> (X1 c1) (<span class="kn">global</span> (indt ¬´nat¬ª)) (X1 c1)  /* suspended on X1 */</blockquote><blockquote class="alectryon-message"><span class="kn">Universe</span> <span class="nf">constraints</span>:
UNIVERSES:
 {tutorial_coq_elpi_HOAS.<span class="mi">13</span>} |=
   <span class="kt">Set</span> &lt;= tutorial_coq_elpi_HOAS.<span class="mi">13</span>
ALGEBRAIC UNIVERSES:
 {}
UNDEFINED UNIVERSES:

WEAK CONSTRAINTS:

</blockquote></div></div></small></span></pre><p>In the value of raw <code class="e elpi"><span class="n-ElpiVariable">T</span></code> we can see that the hole in <code class="highlight coq"><span class="n">x</span> <span class="o">+</span> <span class="n">_</span></code>, which occurs under the
binder <code class="e elpi"><span class="n-ElpiVariable">c0\</span> </code>, is represented by an Elpi unification variable <code class="e elpi"><span class="n-ElpiVariable">X1</span> c0</code>, that
means that <code class="e elpi"><span class="n-ElpiVariable">X1</span></code> sees <code class="e elpi">c0</code> (<code class="e elpi">c0</code> is in the scope of <code class="e elpi"><span class="n-ElpiVariable">X1</span></code>).</p>
<p>The constraint is this time a bit more complex. Let's dissect it:</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->{c<span class="m m-ElpiInteger">0</span> c1} : decl c1 `x` (global (indt ¬´nat¬ª))
  <span class="k k-ElpiKeyword">?-</span> evar (<span class=" -ElpiVariable">X1</span> c1) (global (indt ¬´nat¬ª)) (<span class=" -ElpiVariable">X1</span> c1)  <span class="c">/* suspended on X1 */</span></pre><p>Here <code class="highlight coq"><span class="o">{...}</span></code> is the set of names (not necessarily minimized) used in the
constraint, while <code class="highlight coq"><span class="o">?-</span></code> separates the assumptions (the context) from the
conclusion (the suspended goal).</p>
<p>The mapping between Coq and Elpi is:</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->Coq-Elpi mapping:
RAW:
?X15 &lt;-&gt; X1
ELAB:
?X15 &lt;-&gt; X1
</pre><p>where <code class="highlight coq"><span class="nl">?X13</span></code> can be found in Coq's sigma:</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon -->EVARS:
 ?X15==[x |- nat] (internal placeholder) {?elpi_evar}
 ?X14==[x |- nat =&gt; ?elpi_evar] (internal placeholder)
 ?X13==[x |- Type =&gt; nat] (internal placeholder)

SHELF:
FUTURE GOALS STACK:
 ?X15
</pre><p>As expected both Elpi's constraint and Coq's evar map record a context
with a variable <code class="e elpi">x</code> (of type <code class="highlight coq"><span class="n">nat</span></code>) which is in the scope of the hole.</p>
<p>Unless one is writing a tactic, Elpi's constraints are just used to
represent the evar map. When a term is assigned to a variable 
the corresponding constraint is dropped. When one is writing a tactic,
things are wired up so that assigning a term to an Elpi variable
representing an evar resumes a type checking goal to ensure the term has
the expected type.
We will explain this in detail in the tutorial about tactics.</p>
<div class="section" id="outside-the-pattern-fragment">
<h2><a class="toc-backref" href="#toc-entry-9">Outside the pattern fragment</a></h2>
<p>This encoding of evars is such that the programmer does not need to care
much about them: no need to carry around an assignment/typing map like the
Evar map, no need to declared new variables there, etc. The programmer
can freely call Coq API passing an Elpi term containing holes.</p>
<p>There is one limitation, though. The rest of this tutorial describes it
and introduces a few APIs and options to deal with it.</p>
<p>The limitation is that the automatic declaration and mapping
does not work in all situations. In particular it only works for Elpi
unification variables which are in the pattern fragment, which mean
that they are applied only to distinct names (bound variables).</p>
<p>This is the case for all the <code class="highlight coq"><span class="o">{{</span> <span class="n">_</span> <span class="o">}}</span></code> one writes inside quotations, for
example, but it is not hard to craft a term outside this fragment.
In particular we can use Elpi's substitution (function application) to
put an arbitrary term in place of a bound variable.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input alectryon-failed" for="tutorial-coq-elpi-hoas-v-chk15"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="si">{{</span> <span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x + _ <span class="si">}}</span><span class="k k-ElpiKeyword">,</span>
  <span class="c">% remark the hole sees x</span>
  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">N</span> <span class=" -ElpiVariable">Ty</span> <span class=" -ElpiVariable">Bo</span><span class="k k-ElpiKeyword">,</span>
  <span class="c">% 1 is the offending term we put in place of x</span>
  <span class=" -ElpiVariable">Bo1</span> <span class="k k-ElpiKeyword">=</span> <span class=" -ElpiVariable">Bo</span> <span class="si">{{</span> <span class="mi">1</span> <span class="si">}}</span><span class="k k-ElpiKeyword">,</span>
  <span class="c">% Bo1 is outside the pattern fragment</span>
  coq.say <span class="s2">&quot;Bo1 (not in pattern fragment) =&quot;</span> <span class=" -ElpiVariable">Bo1</span><span class="k k-ElpiKeyword">,</span>
  <span class="c">% boom</span>
  coq.typecheck <span class=" -ElpiVariable">Bo1</span> <span class="si">{{</span> nat <span class="si">}}</span> ok.

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Bo1 (not <span class="kr">in</span> <span class="nb">pattern</span> fragment) = 
app
 [<span class="kn">global</span> (const ¬´Nat.add¬ª), 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], 
  X0 (app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)])]</blockquote><blockquote class="alectryon-message">Flexible term <span class="kn">outside</span> <span class="nb">pattern</span> fragment:
X0 (app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)])</blockquote></div></div></small></span></pre><p>This snippet fails hard, with the following message:</p>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon --><span class=" -ElpiVariable">Flexible</span> term outside pattern fragment:
<span class=" -ElpiVariable">X0</span> (app <span class="k k-ElpiKeyword">[</span>global (indc ¬´<span class=" -ElpiVariable">S</span>¬ª)<span class="k k-ElpiKeyword">,</span> global (indc ¬´<span class=" -ElpiVariable">O</span>¬ª)<span class="k k-ElpiKeyword">]</span>)</pre><p>Indeed <code class="e elpi"><span class="n-ElpiVariable">Bo1</span></code> contains a term outside the pattern fragment,
the second argument of <code class="highlight coq"><span class="n">plus</span></code>, which is obtained by replacing
<code class="e elpi">c0</code> with <code class="highlight coq"><span class="o">{{</span> <span class="mi">1</span> <span class="o">}}</span></code> in <code class="e elpi"><span class="n-ElpiVariable">X0</span> c0</code>.</p>
<p>While programming Coq extensions in Elpi, it may happen that we want to
use a Coq term as a syntax tree (with holes) and we need to apply
substitutions to it but we don't really care about the scope of holes.
We would like these holes to stay <code class="highlight coq"><span class="o">{{</span> <span class="n">_</span> <span class="o">}}</span></code> (a fresh hole which sees the
entire context of bound variables). In some sense, we would like <code class="highlight coq"><span class="o">{{</span> <span class="n">_</span> <span class="o">}}</span></code>
to be a special dummy constant, to be turned into an actual hole on the
fly when needed.</p>
<p>This use case is perfectly legitimate and is supported by all APIs taking
terms in input thanks to the <a class="macro ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L220">&#64;holes!</a> option.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk16"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="si">{{</span> <span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x + _ <span class="si">}}</span><span class="k k-ElpiKeyword">,</span>
  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">N</span> <span class=" -ElpiVariable">Ty</span> <span class=" -ElpiVariable">Bo</span><span class="k k-ElpiKeyword">,</span>
  <span class=" -ElpiVariable">Bo1</span> <span class="k k-ElpiKeyword">=</span> <span class=" -ElpiVariable">Bo</span> <span class="si">{{</span> <span class="mi">1</span> <span class="si">}}</span><span class="k k-ElpiKeyword">,</span>
  coq.say <span class="s2">&quot;Bo1 before =&quot;</span> <span class=" -ElpiVariable">Bo1</span><span class="k k-ElpiKeyword">,</span>
  <span class="c">% by loading this rule in the context, we set</span>
  <span class="c">% the option for the APIs called under it</span>
  <span class="k k-ElpiKeyword">@</span>holes! <span class="k k-ElpiKeyword">=&gt;</span> coq.typecheck <span class=" -ElpiVariable">Bo1</span> <span class="si">{{</span> nat <span class="si">}}</span> ok<span class="k k-ElpiKeyword">,</span>
  coq.say <span class="s2">&quot;Bo1 after =&quot;</span> <span class=" -ElpiVariable">Bo1</span>.

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Bo1 <span class="nb">before</span> = 
app
 [<span class="kn">global</span> (const ¬´Nat.add¬ª), 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], 
  X0 (app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)])]</blockquote><blockquote class="alectryon-message">Bo1 <span class="nb">after</span> = 
app
 [<span class="kn">global</span> (const ¬´Nat.add¬ª), 
  app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], X1]</blockquote><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">  Bo = c0 \
app [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, X1]</blockquote><blockquote class="alectryon-message"> Bo1 = app
[<span class="kn">global</span> (const ¬´Nat.add¬ª), 
 app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], X1]</blockquote><blockquote class="alectryon-message">N = `x`</blockquote><blockquote class="alectryon-message">T = <span class="kr">fun</span> `x` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \ app [<span class="kn">global</span> (const ¬´Nat.add¬ª), c0, X1]</blockquote><blockquote class="alectryon-message">Ty = <span class="kn">global</span> (indt ¬´nat¬ª)</blockquote><blockquote class="alectryon-message">  _uvk_15_ = c0 \
X1</blockquote><blockquote class="alectryon-message">Syntactic constraints:
 <span class="nb">evar</span> (X1) (<span class="kn">global</span> (indt ¬´nat¬ª)) (X1)  /* suspended on X1 */</blockquote><blockquote class="alectryon-message"><span class="kn">Universe</span> <span class="nf">constraints</span>:
UNIVERSES:
 {tutorial_coq_elpi_HOAS.<span class="mi">14</span>} |=
   <span class="kt">Set</span> &lt;= tutorial_coq_elpi_HOAS.<span class="mi">14</span>
ALGEBRAIC UNIVERSES:
 {}
UNDEFINED UNIVERSES:

WEAK CONSTRAINTS:

</blockquote></div></div></small></span></pre><p>Note that after the call to <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L1353">coq.typecheck</a>, <code class="e elpi"><span class="n-ElpiVariable">X0</span></code> is assigned the
term <code class="e elpi"><span class="n-ElpiVariable">_</span><span class="err">\</span> <span class="n-ElpiVariable">X1</span></code>, that means that the offending argument has been pruned
(discarded).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All APIs taking a term support the <a class="macro ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L220">&#64;holes!</a> option.</p>
</div>
<p>In addition to the <a class="macro ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L220">&#64;holes!</a> option, there is a class of APIs which can
deal with terms outside the pattern fragment. These APIs take in input a term
<em>skeleton</em>. A skeleton is not modified in place, as <a class="builtin ghref reference external" href="https://github.com/LPCIC/coq-elpi/blob/a15ded3f70d108a640db1d64f344e47ab08fe2a6/coq-builtin.elpi#L1353">coq.typecheck</a>
does with its first argument, but is rather elaborated to a term related to it.</p>
<p>In some sense APIs taking a skeleton are more powerful, because they can
modify the structure of the term, eg. insert a coercions, but are less
precise, in the sense that the relation between the input and the output
terms is not straightforward (it's not unification).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">nat2bool</span> n := <span class="kr">match</span> n <span class="kr">with</span> O =&gt; false | _ =&gt; true <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> bool_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-coq-elpi-hoas-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-coq-elpi-hoas-v-chk17"><span class="kn">Elpi</span> <span class="kn">Query</span> <span class="si">lp:{{</span>

  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="si">{{</span> <span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; x &amp;&amp; _ <span class="si">}}</span><span class="k k-ElpiKeyword">,</span>
  <span class=" -ElpiVariable">T</span> <span class="k k-ElpiKeyword">=</span> <span class="k k-ElpiKeyword">fun</span> <span class=" -ElpiVariable">N</span> <span class=" -ElpiVariable">Ty</span> <span class=" -ElpiVariable">Bo</span><span class="k k-ElpiKeyword">,</span>
  <span class=" -ElpiVariable">Bo1</span> <span class="k k-ElpiKeyword">=</span> <span class=" -ElpiVariable">Bo</span> <span class="si">{{</span> <span class="mi">1</span> <span class="si">}}</span><span class="k k-ElpiKeyword">,</span>
  coq.elaborate-skeleton <span class=" -ElpiVariable">Bo1</span> <span class="si">{{</span> bool <span class="si">}}</span> <span class=" -ElpiVariable">Bo2</span> ok

<span class="si">}}</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Query</span> assignments:</blockquote><blockquote class="alectryon-message">  Bo = c0 \
app [<span class="kn">global</span> (const ¬´andb¬ª), c0, X0 c0]</blockquote><blockquote class="alectryon-message"> Bo1 = app
[<span class="kn">global</span> (const ¬´andb¬ª), app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)], 
 X0 (app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)])]</blockquote><blockquote class="alectryon-message"> Bo2 = app
[<span class="kn">global</span> (const ¬´andb¬ª), 
 app
  [<span class="kn">global</span> (const ¬´nat2bool¬ª), 
   app [<span class="kn">global</span> (indc ¬´S¬ª), <span class="kn">global</span> (indc ¬´O¬ª)]], X1]</blockquote><blockquote class="alectryon-message">N = `x`</blockquote><blockquote class="alectryon-message">T = <span class="kr">fun</span> `x` (<span class="kn">global</span> (indt ¬´nat¬ª)) c0 \ app [<span class="kn">global</span> (const ¬´andb¬ª), c0, X0 c0]</blockquote><blockquote class="alectryon-message">Ty = <span class="kn">global</span> (indt ¬´nat¬ª)</blockquote><blockquote class="alectryon-message">_uvk_21_ = X0</blockquote><blockquote class="alectryon-message">Syntactic constraints:
 <span class="nb">evar</span> (X2) (<span class="kn">global</span> (indt ¬´bool¬ª)) X1  /* suspended on X2, X1 */</blockquote></div></div></small></span></pre><p>Here <code class="e elpi"><span class="n-ElpiVariable">Bo2</span></code> is obtained by taking <code class="e elpi"><span class="n-ElpiVariable">Bo1</span></code>, considering all
unification variables as holes and all <code class="highlight coq"><span class="o">{{</span> <span class="kt">Type</span> <span class="o">}}</span></code> levels as fresh
(the are none in this example), and running Coq's elaborator on it.</p>
<p>The result is a term with a similar structure (skeleton), but a coercion
is inserted to make <code class="e elpi">x</code> fit as a boolean value, and a fresh hole <code class="e elpi"><span class="n-ElpiVariable">X1</span></code> is
put in place of the term <code class="e elpi"><span class="n-ElpiVariable">X0</span> (app <span class="k-ElpiKeyword">[</span>global <span class="o">(</span>indc <span class="err">¬´</span><span class="n-ElpiVariable">S</span><span class="err">¬ª</span><span class="o">)</span><span class="k-ElpiKeyword">,</span> global <span class="o">(</span>indc <span class="err">¬´</span><span class="n-ElpiVariable">O</span><span class="err">¬ª</span><span class="o">)</span><span class="k-ElpiKeyword">]</span><span class="o">)</span></code>
which is left untouched.</p>
<p>Skeletons and their APIs are described in more details in the tutorial
on commands.</p>
<p>That is all for this tutorial. You can continue by reading the tutorial
about
<a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_coq_elpi_command.html">commands</a>
or the one about
<a class="reference external" href="https://lpcic.github.io/coq-elpi/tutorial_coq_elpi_tactic.html">tactics</a>.</p>
</div>
</div>
</div>
</div>
</div></body>
</html>
